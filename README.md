# 🍽 오늘 뭐 먹지? (Tasteful-AI)

---

**AI 메뉴 추천 & 맛집 지도 검색 & 오픈 채팅**

![브로셔 이미지 2025-02-05 오전 2 01 51](https://github.com/user-attachments/assets/d66f7b57-b17b-4ccf-963b-ca83c7cf2b2e)

<aside>


## **💡 사용자 취향 기반 AI 메뉴 추천 서비스**

### **“점심, 저녁 무엇을 먹을 지 매번 고민하지마세요!“**

**바쁘신 시간을 살아가는 현대인의 메뉴 결정 시간을 절약해주는 AI 기반 메뉴 추천 어플리케이션 입니다. 추천 받은 메뉴를 지도에서 검색하여 맛집을 찾을 수 있습니다.**

**그리고 추천 받은 메뉴와 맛집 정보를 오픈 톡방에서 함께 나누세요!** 

</aside>

---

## 🍙 KEY SUMMARY

<details>
<summary><h3>🔍 단일 서버 vs. 이중 서버, 성능 차이는 얼마나 날까?</h3></summary>

- 테스트 개요
    - Redis 기반 캐싱을 적용한 상태에서 단일 서버와 이중 서버 환경에서의 성능차이를 측정
    - 부하 테스트(Load Test)를 수행하여 트랜잭션 처리 속도를 비교하고, 서버 확장성에 따른 성능 변화를 분석
- 테스트 환경
    - JMeter를 사용하여 TPS(Transactions Per Second) 측정
    - 테스트 조건
        - User(Concurrent Users) : 200명
        - Duration(Seconds) : 20초
        - Loop Count: 3000
- 문제상황
    - JMeter를 사용해 부하 테스트를 진행한 결과, 단일 서버 환경에서 일정 TPS를 유지하다가 특정 시점 이후 성능이 급격히 감소되며 요청 실패
- 원인분석
    - 단일 서버 리소스의 한계 : 많은 사용자가 동시에 요청을 보낼 때, 단일 서버가 이를 모두 처리하기에 한계가 있음
    - CPU 및 메모리 사용량 급증 : 일정 TPS를 유지하긴 하지만, 시간이 지남에 따라 서버의 CPU 및 메모리 사용량이 포화 상태에 도달
    - 부하가 일정 수준을 넘어서면 응답 시간이 증가하고, 일부 요청 또는 요청이 타임아웃 또는 실패
    - Redis 캐싱을 적용했는데도 요청량 증가로 인한 단일 서버의 처리가 한계에 도달
- 해결방법
    - 서버 확장(Scaling Up → Scaling Out)
        - 기존 단일 서버(인스턴스 1개)에서 2개의 서버(이중 인스턴스)로 확장하여 부하를 분산
        - 로드 밸런서를 활용하여 요청을 두 개의 서버에 분산 처리
    - 테스트 조건을 동일하게 유지 후 비교
        - TPS 비교를 통해 성능 향상 정도를 분석
- 결과
    - TPS가 2배 가까이 향상되었고, 처리량이 증가하는 것이 확인됨
    - 단일 서버에서 발생하던 성능 저하 및 요청 실패 문제가 개선

![단일 서버 (특정 시간 이후 요청 실패)](attachment:412c4fb1-781c-450a-b415-6720a3482282:스크린샷_2025-02-07_오전_12.52.53.png)

-단일 서버 (특정 시간 이후 요청 실패)

![2개의 서버 (모든 요청 처리)](attachment:fc0f55c4-741b-4640-ba6b-6380c586653d:스크린샷_2025-02-06_오후_5.19.01.png)

-2개의 서버 (모든 요청 처리)

![Aggregate Report.png](attachment:b7118656-84b9-4a6d-957c-8aa7922bdf7c:0f7cbd52-efbe-4705-83fe-aa714a749826.png)

-결과 : 총 60만개의 데이터가 에러 없이 처리되는 것을 확인

| 환경 | 평균 TPS | 최대 TPS | 요청 실패율 |
| --- | --- | --- | --- |
| 단일 서버(1개 인스턴스) | 약 280 TPS | 320 TPS | 66.7% |
| 이중 서버(2개 인스턴스) | 약 540 TPS | 580 TPS | 요청 실패 없음 |

</details>


---

## 🍙 인프라 설계도


![오늘 뭐 먹지__최종 drawio](https://github.com/user-attachments/assets/06df3c71-e71d-41b4-931b-06062133ff20)


<details>
<summary><h3>🔧 최적의 인프라 설계, 이렇게 하면 됩니다!</h3></summary>

- 배포 및 CI/CD
    - **GitHub & GitHub Actions** : 코드가 GitHub에 업로드되면 GitHub Actions를 활용하여 자동으로 빌드 및 배포가 진행됩니다.
    - **Docker** : 애플리케이션이 Docker 컨테이너로 패키징되어 배포됩니다.

- 프론트엔드
    - **React** 기반의 프론트엔드 애플리케이션이 Amazon CloudFront를 통해 배포 됩니다.
    - **Route 53**을 사용하여 도메인을 관리하고, CloudFront를 통해 정적 자원을 빠르게 제공하도록 설정되어 있습니다.

- 백엔드
    - 백엔드는 **Spring Boot** 기반 애플리케이션으로  AWS EC2 인스턴스에서 실행됩니다.
    - ALB (Application Load Balancer)를 사용하여 사용자 요청을 백엔드 서버 2개로 라우팅합니다.

- 데이터베이스 및 캐시
    - **MySQL** : 애플리케이션의 주요 데이터를 저장하며 앱 서버와 분리된 EC2 인스턴스에 배포되어있습니다.
    - **Redis** : 자주 사용하는 데이터를 저장하는 메모리로 앱 서버와 분리된 EC2 인스턴스에 배포되어있습니다.

- 클라우드 스토리지
    - **S3**로 프로젝트에서 사용하는 이미지를 저장하고 관리하고 있습니다.
    - 프론트 배포를 위해 **S3**에 프론트 파일들을 업로드해두었습니다.

- 외부 API
    - **Open AI(gpt 3.5 turbo)**의 API로 메뉴추천을 위한 AI를 연결하였습니다.
    - **Kakao Map API**를 통해 주변의 맛집을 검색하는 기능을 도입하였습니다.

</details>

---

## 🍙 주요 기능 MVP


<details>
<summary><h3>🖤 인증/인가 (Spring Security)</h3></summary>

# 🔐 인증 인가 Authentication/Authorization

---

## **1. 개요**

Spring Security와 JWT를 활용하여 무상태 인증을 구현하고, Redis를 이용한 실시간 토큰 검증 및 블랙리스트 관리를 통해 보안을 강화하였습니다. 이를 통해 확장성과 성능을 동시에 확보하며, 실무에서 요구되는 보안 요건을 충족합니다.

---

## **2. 주요 기능**

### ☑️ **JWT 기반 인증**

### 🔹 **토큰 발급 및 검증**

- 로그인 성공 시 **Access Token**과 **Refresh Token** 발급
- **Refresh Token**은 Redis에 저장하며 TTL(Time-To-Live) 설정으로 만료 관리
- **Access Token**은 요청마다 Spring Security 필터를 통해 검증하여 보안 강화

### 🔹 **로그아웃 처리**

- Access Token은 **Redis 블랙리스트에 등록**하여 유효기간 동안 무효화
- Refresh Token은 **Redis에서 삭제**하여 추가 인증 방지
- 로그아웃 후 블랙리스트에 포함된 토큰은 즉시 인증 실패 처리

### ☑️ **Redis 기반 토큰 관리**

### 🔹 **Refresh Token 저장 및 관리**

- Redis에 사용자 ID를 키로 저장하여 **만료 기간을 명확하게 관리**
- TTL을 활용하여 자동 삭제 처리

### 🔹 **Access Token 블랙리스트 관리**

- 로그아웃 시 만료된 토큰을 Redis에 등록하여 **재사용 방지**
- 모든 요청에서 **토큰 유효성을 실시간으로 검증**

### ☑️ **회원 관리 기능**

### 🔹 **회원가입**

- 이메일 및 닉네임 **중복 체크** 후 저장
- 비밀번호 **Bcrypt 암호화 저장**하여 보안 강화

### 🔹 **비밀번호 변경**

- 현재 비밀번호 **검증 후 변경 가능**
- 변경된 비밀번호는 **암호화 저장**

### 🔹 **회원 탈퇴**

- 비밀번호 검증 후 **Soft Delete** 방식 적용 (데이터 무결성 유지)

---

## **3. 기술적 성과**

### 🔹 **무상태 인증 (Stateless Authentication)**

- 서버가 **세션을 저장하지 않으므로** 수평 확장(Scale-Out) 및 로드 밸런싱에 유리
- 클라이언트와 서버 간 **빠른 인증 처리** 가능

### 🔹 **보안 강화**

- **CORS 정책** 적용으로 안전한 요청 처리
- **Custom Exception Handling**을 통한 인증 및 권한 오류 중앙 관리
- 로그아웃 시 **블랙리스트 처리**를 통해 만료된 토큰 재사용 방지
- TTL 기반 토큰 관리로 **보안성을 향상**

### 🔹 **사용자 경험 개선**

- TTL 기반 만료 관리로 **성능 최적화 및 부하 감소**
- Redis를 활용한 **빠른 검증**으로 응답 속도 향상 및 사용자 편의성 증대

</details>



<details>
<summary><h3>🖤 역할 및 권한 구조</h3></summary>

# 🪪 관리자와 일반회원 Member

---

## **1. 개요**

서비스 운영을 위해 **관리자(Admin)와 일반 회원(Member)**의 역할을 구분하여 권한을 부여합니다. 각 역할에 따라 접근 가능한 기능이 다르며, 이를 통해 **보안성과 운영 효율성을 향상**시킵니다.

---

## **2. 역할 및 권한**

### ☑️ **관리자(Admin)**

- 시스템 운영 및 사용자 관리 권한 보유
- 회원 관리 페이지에서 전체 사용자 목록 조회 가능
- 일반 회원 계정 삭제 가능
- 채팅방 생성 및 삭제, 채팅방 이름 변경 가능

### ☑️ **일반 회원(Member)**

- 회원가입 및 로그인
- AI 추천 및 지도 기반 맛집 검색 기능 사용
- 채팅방 참여 및 메시지 전송 가능

☑️ **각 역할(Role)에 따라 접근할 수 있는 기능이 다르며, 이를 통해 보안성과 운영 효율성을 높였습니다.**

---

## **3. 인가 적용 영역**

### ☑️ **사용자 관리 & 계정 권한**

- **관리자(Admin)**: 회원 관리 및 계정 삭제 가능
- **일반 회원(Member)**: 가입, 로그인 및 서비스 이용 가능

### ☑️ **채팅방 기능**

- **관리자(Admin)**: 채팅방 생성 및 삭제, 채팅방 이름 변경 가능
- **일반 회원(Member)**: 채팅방 입장 및 메시지 전송 가능

### ☑️ **AI 추천 및 지도 검색 기능**

- **모든 회원 (Member, Admin) 사용 가능**
    - AI 추천을 통해 개인화된 메뉴 추천 제공
    - 지도에서 키워드 검색을 통해 맛집 탐색 가능

---

## **4. 역할 및 권한 관리 방식**

### ☑️ **Spring Security 기반 권한 관리**

- 모든 API 요청은 **Spring Security 필터에서 JWT 토큰을 검증**하여 권한(Role) 확인
- **관리자(Admin)만 접근 가능한 API**는 추가적인 권한 체크 적용
- 비로그인 사용자는 AI 추천 및 지도 검색 일부 기능만 제한적으로 사용 가능

### ☑️ **JWT 기반 접근 제어**

- 로그인 시 발급된 **JWT 토큰을 이용하여 사용자 권한(Role) 검증**
- JWT 토큰 내 사용자 역할 정보 포함 (role: ADMIN 또는 role: MEMBER)
- 계정이 삭제된 경우, 기존 JWT는 **무효화되어 모든 서비스 접근 차단**

---

## **5. MVP 기준 인가 방식을 선택한 이유**

☑️ **보안성**: JWT를 활용한 인증 및 권한 검증을 통해 불법 접근 차단

☑️ **확장성**: Spring Security + WebSocket 기반 인가로 다양한 기능에 일관된 접근 제어 적용 가능

☑️ **운영 효율성**: 관리자가 직접 계정 및 채팅방을 운영하여 원활한 서비스 유지

</details>



<details>
<summary><h3>🖤 사용자 프로필 이미지 관리 (AWS S3)</h3></summary>

# 🎆 이미지 업로드 Image

---

## **1. 개요**

AWS S3를 활용하여 **사용자 프로필 이미지 관리 기능**을 구현하였습니다. S3는 **높은 가용성과 확장성**을 제공하며, 간단한 API를 통해 **파일 업로드, 다운로드, 삭제** 등의 작업을 지원합니다. 이를 통해 대량의 사용자 이미지를 효율적으로 저장하고 관리할 수 있으며, 보안 및 최적화 기능을 적용하여 안전한 서비스 운영이 가능합니다.

---

## **2. 주요 기능**

### ☑️ **이미지 업로드**

- 사용자가 **프로필 이미지를 업로드**하면, **AWS S3 버킷에 저장**
- 업로드된 파일은 **고유한 파일명(`UUID` 적용)으로 관리**하여 중복 방지
- 파일 형식 및 크기 제한을 설정하여 **보안 및 저장소 효율성 확보**

### ☑️ **이미지 다운로드 및 조회**

- 저장된 **이미지 URL을 사용자 프로필 데이터에 저장**하여 프론트엔드에서 접근 가능
- **`CDN`과 결합하여 빠른 이미지 로딩 속도 제공**

### ☑️ **이미지 삭제**

- 사용자가 프로필 이미지를 변경할 경우, 기존 이미지는 **S3에서 자동 삭제**
- 계정 삭제 시, 관련된 모든 이미지 데이터도 함께 제거됨

---

## **3. 동작 흐름**

1. 사용자가 프로필 이미지를 업로드 요청
2. **`UUID`를 사용해 발급한 `uniqueName`으로 S3에 업로드**
3. 업로드 완료 후 **S3의 URL을 DB에 저장**하여 프로필 이미지로 활용
4. 필요 시 이미지 조회 및 다운로드 가능
5. 사용자가 프로필 이미지를 변경하면 기존 이미지 자동 삭제 후 새로운 이미지 저장
6. 계정 삭제 시 관련 이미지 자동 정리

---

## **4. 보안 및 최적화**

- **`ACL` 정책 및 버킷 정책을 활용한 접근 제어**
- **`CloudFront`와 연동하여 이미지 캐싱 및 빠른 응답 속도 제공**
- **`VPC Endpoint`를 활용하여 안전한 네트워크 접근 관리**
- **멀티 리전 복제(Multi-Region Replication) 적용으로 데이터 가용성 보장**

---

## **5. 기술적 성과**

### 💥 **확장성과 가용성 확보**

- 대량의 사용자 이미지 데이터를 안정적으로 저장 가능
- 확장성이 뛰어나며 트래픽 증가에도 원활한 운영 가능

### 💥 **빠른 이미지 제공**

- **`CloudFront`와 연계하여 전 세계 어디서든 빠른 이미지 로딩 제공**
- **`Edge Location`을 활용한 이미지 서빙 최적화**

### 💥 **보안 강화**

- **S3 버킷 정책 및 IAM 역할을 설정하여 외부 접근 차단**
- **S3 서버 측 암호화(SSE) 및 객체 잠금(Object Lock) 적용으로 데이터 보호**

</details>



<details>
<summary><h3>🖤 개인 취향을 반영한 맞춤형 메뉴 추천</h3></summary>

# **🍱** 개인 취향 카테고리 Taste

---

## **1. 개요**

사용자의 **취향 데이터를 반영한 AI 기반 메뉴 추천 시스템**을 제공합니다. 사용자는 첫 로그인 시 **선호하는 음식 장르, 좋아하는 음식, 싫어하는 음식, 식단 성향, 맵기 단계** 총 **5개의 카테고리**를 설정할 수 있으며, **각 카테고리당 최대 5개 항목을 선택 가능**합니다. (건너뛰기로 생략 가능)

사용자의 취향 데이터는 **AI 추천 프로세스에 반영되어 더욱 개인화된 메뉴 추천**이 이루어지며, 사용자는 **마이페이지에서 언제든지 취향 정보를 수정할 수 있습니다.**

---

## **2. 사용자 취향 데이터와 AI 연동**

- AI 메뉴 추천 시, **서버는 사용자의 취향 정보를 포함한 프롬프트를 OpenAI에 전달**하여, 사용자의 선호도를 반영한 맞춤형 추천을 제공
- 사용자는 **실시간 채팅 형식으로 AI에게 메뉴 추천을 요청**하며, AI는 **JSON 형식의 메뉴 데이터를 반환**
- 사용자의 취향 데이터는 MySQL에 저장되고, **Redis를 활용하여 캐싱하여 빠르게 조회** 가능

---

## **3. 데이터 모델 및 테이블 확장**

### **☑️ 기존 설계**

- `Taste` 테이블에 **List 타입의 5개 컬럼**을 포함하여 취향 데이터를 저장
    - `Genres` (선호 장르)
    - `LikeFoods` (좋아하는 음식)
    - `DislikeFoods` (싫어하는 음식)
    - `DietaryPreferences` (식단 성향)
    - `SpicyLevel` (맵기 단계)

### ☑️ **확장된 설계**

- **기존 단일 테이블(Taste)에서 중간 테이블 5개를 추가하여 구조 개선**
- 새로운 중간 테이블:
    - `TasteGenres`
    - `TasteLikeFoods`
    - `TasteDislikeFoods`
    - `TasteDietaryPreferences`
    - `TasteSpicyLevel`
- **각 중간 테이블과 연결된 개별 테이블 5개를 생성**:
    - `Genres`
    - `LikeFoods`
    - `DislikeFoods`
    - `DietaryPreferences`
    - `SpicyLevel`

---

## **4. 연관 관계 및 최적화**

- **Member(Entity)는 취향 데이터 테이블은 `@OneToMany` 관계로 연동**
    - 취향 데이터 중간 테이블은 Member와 취향 데이터 테이블 `@ManyToOne` 관계
- 각 테이블은 `String` 타입의 컬럼(`genreName`, `likeName`, `dislikeName`, `preferenceName`, `spicyLevel`)을 가짐
- **총 10개의 Repository로 확장**하여 데이터 조회 및 관리 최적화
- **`@EntityGraph` 및 `LEFT JOIN FETCH`를 활용하여 5개의 개별 쿼리를 1개로 최적화**, 성능 향상

---

## **5. 기술적 성과**

### 💥 **개인화된 추천 제공**

- 사용자 취향 데이터를 **AI 모델에 반영하여 정밀한 맞춤형 메뉴 추천 가능**
- 취향 변경 시 **실시간 반영 및 업데이트 가능**

### 💥 **효율적인 데이터 관리**

- **중간 테이블을 활용하여 데이터 정규화 및 확장성 증가**
- **MySQL + Redis 캐싱을 통해 빠른 조회 성능 제공**
- **사용자 데이터 수정 시 일관성 유지**

### 💥 **최적화된 데이터 조회**

- **`@EntityGraph`와 `LEFT JOIN FETCH`를 활용한 쿼리 최적화**
- **5개의 개별 조회 쿼리를 1개의 쿼리로 병합하여 성능 개선**
- **Redis 캐싱을 활용하여 빠른 응답 속도 제공**

### 💥 **확장 가능성**

- **사용자의 취향 데이터 구조를 유연하게 확장 가능**
- **향후 추가적인 취향 카테고리 추가 가능하도록 설계됨**
- **다양한 AI 모델과의 연계를 통해 추천 기능 강화 가능**

</details>



<details>
<summary><h3>🖤 AI 메뉴 추천 시스템 (Spring AI)</h3></summary>

# 🍽 메뉴 추천 AI Chat

---

## **1. 개요**

메뉴 추천 AI은 OpenAI GPT-3.5 Turbo 모델을 활용한 **AI 기반 메뉴 추천 시스템**입니다. 사용자의 취향 데이터를 기반으로 맞춤형 메뉴를 추천하며, Redis와 MySQL을 활용한 데이터 관리 및 성능 최적화를 통해 **빠르고 정확한 추천 서비스**를 제공합니다. API 확장을 통해 **추천 요청, 히스토리 조회, 히스토리 삭제 기능**을 지원하며, 효율적인 데이터 관리를 위한 **Redis 캐싱 및 요청 제한 기능**이 포함됩니다.

---

## **2. 사용자 제공 서비스 및 구현 내용**

### ☑️ **개인화된 메뉴 추천**

- 첫 로그인 시 5가지 카테고리 창에서 선택한 **사용자 취향 데이터**를 기반으로 **`OpenAI GPT-3.5 Turbo`** 모델을 활용하여 **맞춤형 메뉴 추천** 제공
- 사용자는 **채팅 형식**으로 메뉴 추천을 요청하고, AI는 **하나의 메뉴를 JSON 형식으로 반환**

### ☑️ **Redis를 활용한 요청 제한 및 데이터 관리**

- Redis를 활용하여 **추천 요청을 하루 10회로 제한**하며 `TTL(Time-To-Live)` 설정으로 관리
- **요청 초과 시 CustomException을 통해 예외 메시지 반환**
- **추천 히스토리는 MySQL에 저장** 후 Redis를 이용해 캐싱하여 빠른 조회 성능 확보

### ☑️ **API 확장**

기존에는 **메뉴 추천 요청 및 Redis 히스토리 삭제 기능만** 제공했으나, MySQL을 연동하여 **데이터를 안정적으로 관리**하고, **하루 1회 초기화하여 Redis로 캐싱하는 기능**을 추가함

- **Redis 키 관리는 `RedisKeyUtil`을 통해 일괄 관리**
- 사용자가 히스토리 내역을 삭제할 경우, **MySQL과 Redis 데이터를 동시에 삭제**하는 로직 구현
- API 엔드포인트 확장:
    - **POST**: 메뉴 추천 요청
    - **GET**: 히스토리 내역 조회
    - **DELETE**: 히스토리 내역 삭제
    
    ---
    

---

## **3. 주요 기술 및 동작 흐름**

### 🔹 **추천 요청 동작 흐름**

1. 사용자가 AI에게 메뉴 추천 요청
2. Spring WebClient인 **`ChatClient`**를 사용하여 **OpenAI GPT-3.5 Turbo 호출** 
3. 사용자 데이터를 포함한 **프롬프트 생성 후 API 요청**
4. AI 모델이 **JSON 형식으로 응답 반환**
5. **사용자에게 결과 반환**

### 🔹 **Redis + AI 데이터 관리**

- AI 추천 결과를 **MySQL과 Redis에 저장**
- Redis에 일정 시간이 지나면 자동 삭제되는 **캐싱 로직 구현**
- 사용자는 원하면 **히스토리 내역을 삭제 가능**

### 🔹 **Spring AI 및 보안 강화**

- **Spring WebClient**를 활용하여 OpenAI API와 연동
- Spring Security와 통합하여 **인증 및 권한 관리 강화**
- **의존성 주입(DI), 트랜잭션 관리** 등 Spring의 기능을 적극 활용

### 🔹 **JSON 데이터 파싱 및 저장**

- AI 응답 데이터를 JSON으로 **파싱 후 사용자 친화적인 형식으로 변환**
- Redis에 캐싱하여 **실시간 처리를 지원하고 DB 접근 최소화**

---

## **4. 기술적 성과**

### 🚀 **개인화된 추천 제공**

- 사용자 취향 데이터를 반영한 **맞춤형 메뉴 추천**

### 🚀 **효율적인 데이터 관리**

- Redis를 활용하여 **하루 단위 데이터 삭제로 서버 부하 감소**
- **요청 제한 및 세션 히스토리 관리로 실시간 처리 최적화**

### 🚀 **비용 절감**

- **요청 횟수 제한 및 프롬프트 최적화**를 통해 OpenAI 호출 비용 최소화

### 🚀 **확장 가능성**

- **Spring Boot와 Redis 기반**으로 유지보수 및 기능 확장이 용이

</details>



<details>
<summary><h3>🖤 카카오 지도 API 연동</h3></summary>

# **🗺** 키워드 지도 검색 Location

---

## **1. 개요**

카카오 지도 API를 활용하여 사용자 위치 기반 맛집 검색 및 키워드 검색 기능을 구현하였습니다. 이를 통해 사용자는 현재 위치를 기준으로 주변 맛집을 탐색하거나 특정 메뉴 및 식당명을 입력하여 검색할 수 있습니다.

---

## **2. 주요 기능**

### ☑️ **사용자 위치 기반 검색**

- 사용자 위치를 기준으로 반경 **5km 내의 맛집 목록 최대 10개 제공**
- 현재 위치를 자동 감지하여 주변 맛집을 추천
- GPS 및 네트워크를 활용한 **정확한 위치 기반 검색**

### ☑️ **키워드 검색**

- 입력된 메뉴나 특정 식당명을 기반으로 관련 장소 정보 반환
- 카카오 지도 **키워드 검색 API 활용**하여 데이터 검색
- 검색 결과를 **리스트 및 지도 UI로 시각화**하여 제공
- 인기 키워드 기반 자동 추천 기능 추가

---

## **3. 검색 방식**

### 🔹 **키워드 기반 검색**

- **AI 추천 메뉴를 키워드로 활용**하여 관련 맛집 검색
- 사용자가 입력한 **키워드를 바탕으로 주변 식당 정보 제공**
- 검색 정확도를 높이기 위한 **유사어 및 동의어 처리** 적용

### 🔹 **식당명 검색**

- 특정 식당명을 입력하면 **해당 위치 및 상세 정보 조회** 가능
- 입력 시 자동 완성 기능 추가로 검색 편의성 향상

### 🔹 **검색 흐름**

1. 사용자가 **키워드 또는 식당명 입력**
2. **API 요청 → JSON 데이터 응답 수신**
3. **결과 데이터를 사용자에게 전달**하며 지도 UI를 통한 시각적 제공
4. **필터 옵션 제공** (예: 리뷰 점수, 가격대, 음식 종류 등)

---

## **4. API 엔드포인트**

- **카카오 지도 키워드 검색 API 사용**
- 반환된 데이터를 가공하여 사용자 경험을 극대화
- 실시간 데이터 업데이트로 최신 검색 결과 제공

</details>



<details>
<summary><h3>🖤 동시간 다중 채팅방 시스템 (WebSocket & STOMP & SockJS)</h3></summary>

# **📨** 오픈 톡방 Chatting

---

## **1. 개요**

오픈 채팅 기능은 **WebSocket + STOMP + Redis Pub/Sub**을 활용하여 **빠른 메시지 전달, 안정성, 확장성**을 확보하며, **관리자 권한을 적용한 다중 채팅방을 지원**합니다. 채팅 기능을 통해 사용자는 원활한 실시간 커뮤니케이션을 경험할 수 있습니다.

---

## **2. 채팅 상세 기능**

### ☑️ **다중 채팅방 지원**

- **관리자** `Admin`는 다양한 주제의 채팅방을 여러 개 생성 가능
- **일반 회원** `Member`은 원하는 채팅방에 입장하여 자유롭게 메시지를 주고 받을 수 있음
- **다중 채널 지원**으로 여러 개의 채팅방에서 동시에 소통 가능

### ☑️ **관리자 권한 기반 채팅방 관리**

- **관리자** `Admin`만 채팅방 **생성, 삭제, 이름 변경** 가능
- **모든 사용자** `Admin`, `Member`는 채팅방 참여 및 메시지 전송 가능

### ☑️ **실시간 메시지 전송 (WebSocket + STOMP)**

- **WebSocket을 활용한 빠른 메시지 전송**으로 즉각적인 응답 제공
- **STOMP 프로토콜 적용**으로 Pub/Sub 방식으로 메시지 구독 가능
- **SockJS 지원**으로 WebSocket 미지원 환경에서도 원활한 연결 유지

### ☑️ **Redis Pub/Sub을 활용한 확장성**

- 서버가 여러 대로 확장되더라도, **Redis Pub/Sub**을 활용하여 모든 서버에서 동일한 메시지 수신 가능
- **로드 밸런싱 환경에서도 안정적인 실시간 채팅 지원**

### ☑️ **최근 메시지 저장 및 로드 (캐싱 적용)**

- 최신 **50개의 메시지를 Redis에 캐싱**하여 빠른 채팅방 입장 및 메시지 로딩 가능
- **DB에 메시지를 저장하여 영속성 유지** 및 데이터 보존

---

## **3. MVP 기준으로 기술 선택한 이유**

### 🚀 **빠른 응답 속도**

- **WebSocket 기반**의 메시지 즉시 전달로 사용자 경험 향상
- **Redis 캐싱을 활용하여** 메시지 로딩 속도 개선

### 🚀 **확장성**

- **Redis Pub/Sub 활용**으로 다중 서버 환경에서도 원활한 메시지 처리 가능
- **로드 밸런싱을 적용하여 서버 부하 분산**

### 🚀 **안정성**

- **SockJS 지원**으로 WebSocket 미지원 환경에서도 원활한 채팅 경험 제공
- 서버 장애 시 데이터 손실 최소화

### 🚀 **관리자 운영**

- **채팅방 생성 및 관리 권한을 관리자에게 부여**하여 서비스 운영의 효율성 증가
- **비정상적인 메시지 스팸 필터링 및 신고 기능 적용**

### 🚀 **사용자 경험 최적화**

- **최근 50개의 메시지를 캐싱하여** 채팅방 입장 시 빠른 로딩 지원
- **UI/UX 최적화**, 사용자 친화적인 인터페이스 제공

</details>

---

## 🍙 기술 스택


| 분류                 | 사용 기술 / 도구                                                     |
|---------------------|-----------------------------------------------------------------
| **🖥 Language**       | Java 21                                                             |
| **📲 IDE**            | IntelliJ IDEA                                                       |
| **🧑🏻‍💻 Backend**       | - Spring Framework 3.3.1 / Spring Boot<br>- Spring Data JPA<br>- Spring Security 6.4.2<br>- Spring AI → OpenAI<br>- WebSocket & STOMP & SockJS  |
| **💁🏻 Frontend**       | - React<br>- Node.js                                                 |
| **🗃 DB & Optimization** | - MySQL 8+<br>- Redis 7.2.7<br>- S3                                  |
| **🚢 Deployment & Distribution** | - Docker<br>- AWS (EC2, S3, CloudFront, Application Load Balancer, Route 53, Certificate Manager)<br>- GitHub Actions |
| **📡 API**            | - OpenAI GPT-3.5 Turbo<br>- Kakao Map                                 |
| **📟 Test**           | - Postman<br>- JMeter<br>- H2                                          |
| **👥 Collaboration**   | - GitHub<br>- Slack<br>- Notion<br>- Figma<br>- ERD Cloud<br>- Canva       |


---

## 🍙 기술적 의사 결정

---


<details>
<summary><h3>💡 Java 버전은 무엇을 사용해야 할까요?</h3></summary>

## 1. 배경 (Background)

- 현재 프로젝트의 장기적인 유지보수성과 성능 최적화를 고려하여, **Java 17과 Java 21 중 어떤 버전을 사용할지** 고민하였습니다.
- Java 17은 안정적인 LTS(Long-Term Support) 버전이며, Java 21은 최신 LTS 버전으로 추가적인 기능과 성능 개선을 포함하고 있습니다.

---

## 2. 요구사항 (Requirements)

- **LTS 지원이 보장되는 안정적인 버전** 사용
- **Spring Boot 3.x 지원 여부** 확인
- **성능 최적화 가능성** (특히, 동시성 처리 및 멀티스레드 환경)
- **코드 간결성과 유지보수성** 향상 가능성

---

## 3. 고려한 대안 (Alternatives)

| 비교 항목 | Java 17 | Java 21 ☑️ |
| --- | --- | --- |
| **출시/버전** | 2021년 출시, LTS 버전 (**2029년 9월까지 지원**) | 2023년 출시, LTS 버전 (**2031년 9월까지 지원**) |
| **Spring Boot 지원** | Spring Boot 3.x.x 버전 이상부터 지원 | **Spring Boot 3.2 이상**에서 완벽 지원 |
| **장점** | • `switch` 패턴 매칭 (Preview)<br>• `record` 클래스 도입<br>• `"""`을 사용한 텍스트 블록 기능 제공 | **• 가상 스레드(Virtual Threads) 도입**<br> - OS 스레드 사용량을 줄이고, 수백만 개의 가상 스레드를 실행 가능<br> - 기존 Java 코드 수정 없이 사용 가능<br>**• 기본 문자 인코딩이 UTF-8로 변경** |

---

## 4. 결정 (Decision)

**Java 21을 선택** ☑️

- Java 21은 **가상 스레드(Virtual Threads)**와 같은 성능 최적화 기능을 제공하며,
- 2031년까지 장기적인 LTS 지원이 보장됩니다.
- 또한, Spring Boot 3.2 이상에서 완벽히 지원되므로 최신 Spring Boot 환경에서도 안정적으로 사용할 수 있습니다.

---

## 5. 근거 (Justification)

- ☑️ **가상 스레드(Virtual Threads)**를 통해 기존의 **동시성 처리 문제 해결** 가능
- ☑️ Java 21은 **UTF-8을 기본값**으로 사용하여 국제화 처리 시 추가적인 설정 불필요
- ☑️ **LTS 버전(2031년까지 지원)**으로 장기 유지보수 가능
- ☑️ 최신 Spring Boot(3.2 이상) 환경과의 **완벽한 호환성**

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **동시성 성능 향상**: 가상 스레드 도입으로 대규모 트래픽 처리 가능
  - **개발 편의성 증가**: 텍스트 블록, `switch` 패턴 매칭, 레코드 클래스 등의 기능 활용
  - **국제화 처리 간소화**: UTF-8 기본 적용으로 인코딩 이슈 최소화
- **부정적 영향**
  - **초기 마이그레이션 비용 발생**: 기존 Java 17 환경에서 Java 21로 업그레이드 시 일부 설정 변경 필요
  - **최신 기능 러닝 커브**: 개발팀이 가상 스레드, 패턴 매칭 등의 새로운 기능을 학습해야 함

---

## 7. 구현 전략 (Implementation Strategy)

1. **Java 21로 업그레이드** 진행 (기존 Java 17 코드와의 호환성 점검)
2. **가상 스레드 적용 테스트** (멀티스레드 환경에서 성능 비교)
3. **Spring Boot 3.2 환경에서의 호환성 확인** (설정 변경 필요 여부 검토)
4. **UTF-8 기본 인코딩 활용** (기존 `file.encoding` 설정 검토)

---

## 8. 향후 고려 사항 (Future Considerations)

- **가상 스레드 활용 극대화**: 기존의 `ExecutorService` 기반 동시성 처리 코드 리팩토링 가능성 검토
- **Spring Boot 3.2 이상으로의 최적화**: 새로운 Spring Framework 기능 활용 가능성 탐색
- **Java 21의 추가적인 기능 활용**: 패턴 매칭 for `switch`, 레코드 패턴 등 최신 기능 학습 및 적용

---

## ☑️ 결론: **Java 21 채택**

Java 21은 **더 긴 LTS 지원(2031년까지)과 성능 최적화 기능**을 포함하고 있으며,
특히 **가상 스레드**는 대규모 트래픽을 처리하는 환경에서 큰 이점을 제공합니다.

결론적으로, **Java 17 대비 성능과 유지보수성이 뛰어나므로 Java 21을 채택하는 것이 적절**합니다.

</details>


<details>
<summary><h3>💡 인증 인가는 어떤 방식으로 해야할까요?</h3></summary>

## 1. 배경 (Background)

현재 프로젝트의 **인증(Authentication) 방식**을 결정하기 위해, **JWT(Json Web Token)** 세션(Session) 기반 인증을 비교하였습니다.
각 방식의 **보안성, 확장성, 유지보수성**을 고려하여 기술적 의사결정을 진행하였습니다.

---

## 2. 요구사항 (Requirements)

- **확장성(Scalability)**: 서버가 여러 대로 확장될 경우 인증 방식이 원활하게 동작해야 함
- **보안(Security)**: 세션 탈취, 토큰 유출 등의 보안 이슈를 최소화해야 함
- **성능(Performance)**: 인증 과정에서 발생하는 서버 부하를 고려
- **유지보수성(Maintainability)**: 개발 및 유지보수가 용이한 방식이어야 함

---

## 3. 고려한 대안 (Alternatives)

| 비교 항목 | JWT (Json Web Token) ☑️ | Session |
| --- | --- | --- |
| **개념** | 클라이언트가 로그인하면 서버에서 JWT를 생성하여 클라이언트에 전달.<br>이후 요청 시 JWT를 포함하여 인증 진행 | 클라이언트가 로그인하면 서버에서 세션을 생성하고,<br>세션 ID를 클라이언트에 전달. 이후 요청 시 세션 ID를 포함하여 인증 진행 |
| **보관 방식** | 클라이언트(브라우저, 모바일 앱 등)에서 JWT를 **로컬 스토리지 또는 쿠키**에 저장 | 서버에서 세션 정보를 저장하며,<br>클라이언트는 세션 ID를 쿠키에 저장 |
| **확장성** | 서버가 상태를 저장하지 않기 때문에<br>**확장성이 뛰어남 (Stateless)** | 서버에서 세션을 관리하므로<br>**서버 부하 증가 가능** |
| **보안** | 토큰이 유출되면 누구나 사용 가능 → **짧은 유효기간 + Refresh Token 필요** | 세션 탈취 위험 존재 → **HTTPS 및 보안 정책 강화 필요** |
| **장점** | ☑️ 서버 부하 없음 (Stateless)<br>☑️ 여러 서비스(API)에서 쉽게 공유 가능<br>☑️ OAuth 같은 인증 시스템과 연동 용이 | ☑️ 세션이 서버에서 관리되므로 보안성이 더 뛰어남<br>☑️ 토큰이 탈취되었을 때 서버에서 강제 만료 가능 |
| **단점** | ❌ 유출 시 즉시 만료가 어렵고 Refresh Token이 필요<br>❌ 토큰 길이가 길어 요청 크기 증가 | ❌ 서버에 부하 발생(Stateful)<br>❌ 세션을 서버에서 유지해야 하므로 확장성 낮음 |

---

## 4. JWT를 선택 (Stateless 인증 방식)

☑️ **확장성이 중요한 서비스**이므로,<br>**상태를 저장하지 않는 방식(JWT)**이 적합

☑️ **OAuth 2.0과의 연동이 용이**하여 소셜 로그인 등과 쉽게 통합 가능

☑️ 서버 부하 감소 (세션을 서버에 저장하지 않기 때문)

---

## 5. 근거 (Justification)

- ☑️ **Stateless 방식**으로 서버 부담이 적음 → API 서버 확장에 유리
- ☑️ **마이크로서비스 및 OAuth 연동**에 적합
- ☑️ **토큰 기반 인증**으로 클라이언트 간 공유 가능
- ☑️ **세션 관리**가 필요하지 않아 유지보수가 용이

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - 서버 확장이 용이함 → **로드 밸런싱**을 통한 확장 가능
  - API 인증이 **독립적으로 동작** (마이크로서비스 아키텍처에서 유리)
  - OAuth 기반 인증과 쉽게 연동 가능
- **부정적 영향**
  - 토큰이 유출되면 **즉시 폐기 불가** (Refresh Token 필요)
  - 요청 크기가 커질 수 있음 (JWT가 비교적 길기 때문)
  - 짧은 TTL(Time To Live) 및 보안 정책 필요 (예: **HTTPS 강제**, HttpOnly 쿠키 사용)

---

## 7. 구현 전략 (Implementation Strategy)

1. **JWT 사용 방식 결정**
   - Access Token & Refresh Token 구조 적용
   - Access Token은 **짧은 유효기간(예: 15~30분) 설정**
   - Refresh Token을 사용하여 재발급 로직 적용
2. **보안 강화**
   - JWT를 **HttpOnly & Secure 쿠키**에 저장하여 XSS 공격 방지
   - HTTPS를 강제하여 네트워크에서 토큰이 유출되지 않도록 보호
3. **로그아웃 및 강제 만료 처리**
   - Redis 등을 활용한 **Blacklist** 기능으로 특정 JWT 차단
4. **JWT 기반 인증**을 Spring Security와 연동
   - Spring Security + JWT로 인증 필터 구현
   - Authentication Filter에서 JWT 검증 및 권한 부여

---

## 8. 향후 고려 사항 (Future Considerations)

- **OAuth 2.0 및 OpenID Connect 연동 검토** (Google, Kakao, Naver 로그인 지원)
- **Refresh Token 관리 방식 개선** (Redis를 활용한 블랙리스트 적용)
- **추가적인 보안 정책 도입** (예: IP 제한, MFA 등)

---

### ☑️ 결론: **JWT 채택 (Session 대비 확장성 및 성능이 우수)**

JWT는 **Stateless 방식**으로, API 기반 서비스에서 서버 부하를 줄이고 확장성을 확보할 수 있는 강력한 인증 방식입니다.

특히 **OAuth 2.0 및 마이크로서비스 아키텍처**와의 연동이 쉬워,
장기적으로 유지보수성과 확장성을 고려했을 때 최적의 선택입니다.

</details>




<details>
<summary><h3>💡 DB는 어떤 것을 사용해야 할까요?</h3></summary>

## 1. 배경 (Background)

현재 프로젝트의 데이터베이스(DBMS)로 **MySQL과 PostgreSQL 중 어떤 것을 사용할지** 결정을 내리기 위해 각각의 장단점을 비교하였습니다.

**읽기 성능, 확장성, 복잡한 쿼리 처리, 대용량 데이터 관리, 동시성 처리** 등의 요소를 고려하여 최적의 DBMS를 선택했습니다.

---

## 2. 요구사항 (Requirements)

- **읽기 성능 최적화**: 빠른 데이터 조회 필요
- **확장성(Scalability)**: 서비스 규모가 커졌을 때 원활한 확장 가능성
- **데이터 구조의 유연성**: JSON 저장 및 복잡한 쿼리 지원 여부
- **동시성(Concurrency)**: 다중 트랜잭션 처리 시 성능 저하 여부
- **사용 편의성**: 개발 및 유지보수 난이도

---

## 3. 고려한 대안 (Alternatives)

| 비교 항목 | MySQL (☑️ 선택) | PostgreSQL |
| --- | --- | --- |
| **유형** | 관계형 데이터베이스 관리 시스템 (**RDBMS**) | 객체 관계형 데이터베이스 관리 시스템 (**ORDBMS**) |
| **아키텍처** | **멀티 스레드 아키텍처**<br>- 한 프로세스가 여러 스레드를 가짐<br>- **높은 메모리 효율성** | **멀티 프로세스 아키텍처**<br>- 각 프로세스가 독립적인 메모리 공간을 가짐<br>- **더 높은 안정성과 확장성** |
| **성능** | **읽기 작업에 최적화** | **복잡한 쿼리, 대용량 데이터 처리, 쓰기 작업에 최적화** |
| **사용 사례** | **웹 애플리케이션, 가벼운 서비스** | **대규모 애플리케이션, 데이터 웨어하우스, 복잡한 시스템** |
| **장점** | ☑️ 읽기 작업에 최적화되어 단순한 쿼리 처리 시 PostgreSQL보다 **뛰어난 성능**<br>☑️ **사용 편의성**이 높음<br>☑️ 역사가 깊고 사용층이 넓어 **자료와 커뮤니티가 풍부** | ☑️ OpenAI API의 **JSON 응답 데이터 저장** 및 검색 최적화<br>☑️ **실시간 채팅 메시지 저장 시 동시성 처리 우수** (MVCC 활용)<br>☑️ **사용자 취향 데이터 저장 및 복잡한 쿼리 지원** (콜렉션, JSONB 지원) |

---

## 4. 결정 (Decision)

☑️ **MySQL을 선택** (읽기 성능 최적화 & 사용 편의성)

- **읽기 성능이 중요**한 웹 애플리케이션 환경에서는 **MySQL이 더 유리**
- **사용 편의성**과 **넓은 커뮤니티 지원**으로 빠른 개발 및 유지보수가 가능
- 대용량 데이터를 다룰 경우 추가적인 **캐싱(Redis) 활용**을 고려하여 성능 보완 가능

---

## 5. 근거 (Justification)

- ☑️ **읽기 성능이 뛰어나므로 웹 애플리케이션에 최적**
- ☑️ **개발자가 많고 자료가 풍부하여 유지보수 용이**
- ☑️ **멀티 스레드 아키텍처로 메모리 효율성 높음**
- ☑️ **스케일아웃(Scale-Out) 및 레플리카(Replication) 확장이 용이**

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **빠른 읽기 성능 제공** → 웹 애플리케이션 속도 향상
  - **사용 편의성**이 높아 개발 속도 증가
  - **넓은 커뮤니티** 및 풍부한 문서 지원
- **부정적 영향**
  - **대량 데이터**의 복잡한 쿼리 처리 성능은 PostgreSQL보다 낮음
  - **실시간 데이터 저장 시 동시성** 문제가 발생할 가능성 있음 → Redis 캐싱 및 샤딩 적용으로 해결

---

## 7. 구현 전략 (Implementation Strategy)

1. **MySQL을 기반으로 데이터 모델링 최적화**
   - 정규화된 테이블 설계
   - 인덱스 최적화 및 쿼리 성능 개선
2. **읽기 성능 향상을 위한 캐싱 적용**
   - **Redis** 활용하여 자주 조회하는 데이터 캐싱
3. **확장성 고려**
   - **Replication(레플리카)**를 활용하여 읽기 부하 분산
4. **대량 데이터 처리를 위한 보완책**
   - **Batch Insert 및 Partitioning** 적용 고려

---

## 8. 향후 고려 사항 (Future Considerations)

- **JSON 데이터 활용 여부** → PostgreSQL 도입 가능성 검토
- **트랜잭션 동시성 최적화** 필요 시 PostgreSQL로 전환 검토
- **실시간 데이터 처리** 개선 필요 시 Redis와의 결합 고려

---

### ☑️ 결론: **MySQL 채택 (웹 애플리케이션 최적화 & 사용 편의성 고려)**

MySQL은 **빠른 읽기 성능**과 **쉬운 사용성**을 제공하며, 웹 애플리케이션 개발에 적합한 DBMS입니다.

대용량 데이터 및 동시성 문제가 발생할 경우, **Redis 캐싱**과 **샤딩**을 활용하여 확장성을 확보하는 방식으로 해결할 수 있습니다.

</details>





<details>
<summary><h3>💡 프로젝트에 적합한 `Architecture` 는 무엇일까요?</h3></summary>

---

## 1. 배경 (Background)

현재 개발 중인 **"오늘 뭐 먹지?"** 프로젝트는 AI 기반 메뉴 추천, 지도 검색, 오픈톡 채팅 기능을 포함한 복합적인 시스템입니다.

서비스 확장성과 유지보수성을 고려했을 때, **도메인 중심 설계(Domain-Driven Design, DDD)**를 기반으로 한 클린 아키텍처와 레이어드 아키텍처의 조합이 적절하다고 판단했습니다.

---

## 2. 요구사항 (Requirements)

- **도메인 독립성 유지**: 비즈니스 로직이 프레임워크(Spring), 데이터베이스, 외부 API에 의존하지 않도록 설계
- **확장성(Scalability)**: 기능 추가 및 변경이 용이한 구조
- **유지보수성(Maintainability)**: 코드 변경이 최소한의 영향만 미치도록 계층별 책임을 명확히 분리
- **테스트 용이성(Testability)**: 핵심 도메인 로직을 쉽게 단위 테스트할 수 있도록 설계
- **팀 협업 최적화**: 각 계층별 역할이 명확하여 협업 시 충돌을 최소화

---

## 3. 고려한 대안 (Alternatives)

| 아키텍처 | 장점 | 단점 |
| --- | --- | --- |
| 레이어드 아키텍처 | 역할이 명확하고 익숙한 구조, 이해하기 쉬움 | 의존성이 아래 계층에 집중될 경우 변경이 어려워질 가능성 |
| 클린 아키텍처 | 도메인 독립성 유지, 확장성과 테스트 용이성 증가 | 초반 설계 및 구현 비용이 높음, 러닝 커브 |
| 헥사고날 아키텍처 | 입출력 포트를 인터페이스로 분리하여 유연성 증가 | 구현 난이도가 비교적 높고 학습 비용 존재 |
| 온리 클린 아키텍처 | 완전히 독립적인 도메인 중심 설계 | 단순한 CRUD 서비스에는 오버 엔지니어링 가능성 |
| 온리 레이어드 아키텍처 | 간단한 프로젝트에 적합, 빠른 개발 가능 | 유지보수성과 확장성이 떨어질 위험 |

**"클린 아키텍처 + 레이어드 아키텍처"**의 조합이 현재 프로젝트의 요구사항과 가장 부합한다고 판단하였습니다.

---

## 4. 결정 (Decision)

클린 아키텍처의 **도메인 독립성**과 레이어드 아키텍처의 **명확한 역할 분리**를 조합하여 프로젝트를 설계합니다.

### 🏛️ **아키텍처 구조**

1. **도메인 계층 (Domain Layer)**
   - 핵심 비즈니스 로직을 담당
   - 어떤 외부 요소에도 의존하지 않음 (순수한 Java 객체)
2. **애플리케이션 계층 (Application Layer)**
   - 유스케이스(Use Case) 처리 담당
   - 서비스 로직을 도메인 계층과 연결
3. **어댑터 계층 (Adapter Layer)**
   - 외부 시스템(DB, API 등)과의 상호작용을 담당
   - Repository, Controller 등이 포함됨
4. **프레임워크 계층 (Framework Layer)**
   - Spring, JPA, Security 등의 외부 기술 사용
   - 인프라 관련 로직 포함 (예: JWT 인증, Redis 캐싱)

---

## 5. 근거 (Justification)

**클린 아키텍처 적용 이유**
- ☑️ **도메인 중심 설계(DDD)**로 핵심 로직 보호
- ☑️ **테스트 용이성** (도메인 계층이 독립적이라 Mocking이 불필요)
- ☑️ **유지보수성 향상** (외부 의존성 변경이 도메인 계층에 영향을 미치지 않음)
- ☑️ **확장성 고려** (추후 다른 프레임워크나 DB로 변경이 쉬움)

**레이어드 아키텍처 적용 이유**
- ☑️ **팀 협업 용이** (Controller, Service, Repository 역할 명확)
- ☑️ **코드 가독성 증가** (기능별로 계층이 분리되어 있어 구조가 직관적)
- ☑️ **Spring의 기본적인 개발 방식과 잘 맞음**

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **유지보수성**: 도메인 로직과 인프라(데이터베이스, API)가 분리되어 변경이 용이함
  - **확장성**: 새로운 기능 추가 시 특정 계층만 수정하면 됨
  - **테스트 용이성**: 도메인 계층이 독립적이라 단위 테스트 작성이 쉬움
- **부정적 영향**
  - **초기 설계 비용 증가**: 클린 아키텍처를 적용하면서 초기 설계 시간이 늘어날 가능성
  - **학습 비용**: 팀원들이 클린 아키텍처의 개념을 숙지해야 함
  - **추가적인 코드 증가**: 계층이 많아지면서 코드 구조가 복잡해질 수 있음

---

## 7. 구현 전략 (Implementation Strategy)

- **도메인 엔티티**를 별도 패키지로 분리하여 외부 의존성 제거 (`domain.model`)
- **서비스 레이어**를 `application.service` 패키지로 관리, 도메인 객체를 활용한 유스케이스 구현
- **인터페이스 어댑터 계층** (`adapter.controller`, `adapter.persistence`)을 통해 인프라 요소를 캡슐화
- **프레임워크 계층** (`infra.config`, `infra.security`)을 별도로 두어 Spring 및 외부 기술을 관리

---

## 8. 향후 고려 사항 (Future Considerations)

- **클린 아키텍처를 점진적으로 적용**: 기존 레이어드 아키텍처 기반으로 시작하고, 점진적으로 도메인 독립성을 강화
- **CQRS 적용 가능성 검토**: 조회 성능 향상을 위해 Command와 Query를 분리할 필요성 고려
- **마이크로서비스 전환 가능성**: 현재는 모놀리식이지만, 특정 기능(추천, 예약 등)은 추후 마이크로서비스로 분리 가능

</details>



<details>
<summary><h3>💡 채팅 기능 구현 방식이 너무 많은데, 어떤게 제일 적합할까요?</h3></summary>

## 1. 배경 (Background)

**다중 사용자 채팅 기능**을 구현하기 위해, **빠른 응답 속도, 안정성, 확장성**을 고려한 적절한 기술 스택을 선정했습니다.

다양한 메시징 시스템(WebSocket, RabbitMQ, Kafka 등)이 존재하지만,
**즉각적인 메시지 전달 및 확장성**이 중요한 채팅 서비스 특성을 반영하여
최적의 방식을 아래와 같이 결정하였습니다.

---

## 2. 요구사항 (Requirements)

- **빠른 응답 속도**: 사용자가 입력한 메시지가 즉시 전송되어야 함
- **양방향 통신 지원**: 실시간 채팅이 가능해야 함
- **확장성(Scalability)**: 서버가 여러 대일 경우에도 메시지가 정상적으로 동기화되어야 함
- **안정성(Reliability)**: 메시지가 유실되지 않고 정확하게 전달될 것

---

## 3. 고려한 대안 (Alternatives)

| 비교 항목 | WebSocket + STOMP + SockJS + Redis Pub/Sub (☑️ 선택) | RabbitMQ | Kafka |
| --- | --- | --- | --- |
| **속도** | ☑️ **빠름** (WebSocket 사용) | ❌ 메시지 큐를 거쳐야 하므로 상대적으로 느림 | ❌ 대규모 스트리밍에 최적화, 채팅 서비스에는 높은 지연 시간 |
| **양방향 통신** | ☑️ **가능** (WebSocket) | ❌ 메시지 브로커 기반이므로 클라이언트 간 직접 통신 어려움 | ❌ 메시지 소비 구조로 인해 WebSocket처럼 즉각적인 응답 불가능 |
| **확장성** | ☑️ **Redis Pub/Sub으로 서버 간 메시지 동기화 가능** | ☑️ 여러 대의 서버 운영 가능하지만 큐 지연 발생 가능 | ☑️ 대규모 확장 가능하지만 실시간 채팅에는 부적합 |
| **안정성** | ☑️ WebSocket 연결 유지 시 안정적 | ☑️ **메시지 보장(ACK, 재전송 지원)** | ☑️ **메시지 내구성 보장** |
| **사용 사례** | ☑️ **실시간 채팅, 알림 시스템** | ❌ **메시지 손실이 치명적인 서비스 (결제 시스템 등)** | ❌ **로그 수집, 데이터 스트리밍, 이벤트 처리** |
| **단점** | ❌ WebSocket이 끊어질 경우 재연결 필요 | ❌ 즉각적인 메시지 전달 어려움 (큐 대기 시간) | ❌ 높은 지연 시간 (채팅 서비스에는 부적합) |

---

## 4. 결정 (Decision)

☑️ **WebSocket + STOMP + SockJS + Redis Pub/Sub**을 선택

- **WebSocket**을 통해 **양방향 실시간 통신** 지원
- **STOMP 프로토콜**을 사용하여 **Pub/Sub 기반 브로드캐스트** 가능
- **SockJS**로 WebSocket 미지원 환경에서도 대응 가능
- **Redis Pub/Sub**을 활용하여 **여러 대의 서버**에서도 메시지 동기화 보장

---

## 5. 근거 (Justification)

- ☑️ **즉각적인 응답**이 중요한 채팅 서비스에 최적화
- ☑️ **WebSocket**을 통해 클라이언트-서버 간 실시간 양방향 통신
- ☑️ **Redis Pub/Sub**으로 서버 간 메시지 동기화 및 확장성 확보
- ☑️ **RabbitMQ/Kafka** 대비 불필요한 오버헤드 제거

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **빠른 응답 속도** → 즉각적인 메시지 전송 가능
  - **확장성 보장** → 여러 대 서버에서 채팅 동기화 가능
  - **가벼운 프로토콜** → 메시지 처리 비용 최소화
- **부정적 영향**
  - **WebSocket 끊어질 시** 재연결 로직 필요
  - **Redis Pub/Sub**은 메시지 내구성 미보장 → 메시지 저장 위해 DB 연동 필요

---

## 7. 구현 전략 (Implementation Strategy)

1. **WebSocket + STOMP 프로토콜 적용**
   - 클라이언트가 WebSocket 통해 STOMP 메시지 주고받도록 구현
2. **SockJS**로 대체 연결 지원
   - WebSocket 미지원 환경은 HTTP 기반 통신으로 대체
3. **Redis Pub/Sub** 통한 서버 간 동기화
   - 여러 서버 존재 시 Redis로 메시지 브로드캐스팅
4. **추가적인 메시지 보장** 위해 DB 연동
   - 채팅 메시지를 MySQL, PostgreSQL, Redis 등에 저장

---

## 8. 향후 고려 사항 (Future Considerations)

- **Redis 대신 Kafka**로 전환 검토 (대규모 사용자 증가 시)
- **메시지 영속성 강화** 위해 DB 연동 및 저장 전략 개선
- **QoS(Quality of Service) 강화** (ACK 메커니즘 추가 가능성 등)

---

### ☑️ 결론: **WebSocket + STOMP + SockJS + Redis Pub/Sub 채택**

WebSocket으로 **즉각적인 메시지 전달**을 보장하면서,<br>
Redis Pub/Sub으로 **서버 간 확장성 및 동기화** 문제를 해결하는 구조를 선택했습니다.

**RabbitMQ/Kafka** 대비 **더 빠른 응답 속도**와 **가벼운 구조**를 유지할 수 있어,<br>
**다중 사용자 채팅 서비스**에 최적화된 솔루션입니다.

</details>




<details>
<summary><h3>💡 AI 모델은 어떤 걸 연결할까요? 그리고 이것을 어떻게 연결해야할까요?</h3></summary>

## 1. 배경 (Background)

**사용자 맞춤 메뉴 추천**을 위한 AI 모델을 선택하기 위해,
Spring AI에서 제공하는 **연결 가능한 AI 모델(OpenAI GPT, Google Gemini 등)** 중,
**성능, 비용, 확장성, 응답 속도** 등의 요소를 고려하여 적절한 모델을 결정하였습니다.

---

## 2. 요구사항 (Requirements)

- **비용 효율성(Cost Efficiency)**: 높은 품질의 응답을 제공하면서도 API 호출 비용을 절감할 수 있는 모델 필요
- **실시간 응답 속도(Response Speed)**: 사용자의 요청에 빠르게 응답할 수 있어야 함
- **문맥 유지 능력(Context Retention)**: 이전 대화 내용을 기억하고 추천의 일관성을 유지할 수 있어야 함
- **Spring AI와의 호환성**: Spring 기반의 애플리케이션에서 손쉽게 연동 가능해야 함

---

## 3. 고려한 대안 (Alternatives)

| 비교 항목 | OpenAI GPT-3.5-Turbo (☑️ 선택) | Google Gemini |
| --- | --- | --- |
| **Spring AI 지원 여부** | ☑️ 공식 지원 (Spring AI 문서 제공) | ☑️ 공식 지원 (Spring AI 문서 제공) |
| **비용 효율성** | ☑️ **비용이 저렴함** (GPT-4보다 낮은 API 사용료) | ❌ OpenAI 대비 상대적으로 비용이 높을 가능성 |
| **응답 속도** | ☑️ **빠른 응답 속도** (최적화된 모델) | ❌ 상대적으로 응답 속도가 느림 |
| **문맥 유지 능력** | ☑️ **긴 문맥 유지 가능** (최대 16K 토큰 지원) | ☑️ **문맥 유지 가능하지만 세부 정보 부족** |
| **모델 성능** | ☑️ **일반적인 텍스트 생성, 분석, 추천 최적화** | ☑️ **멀티모달(이미지+텍스트) 처리 가능** |
| **활용 사례** | ☑️ **사용자 맞춤 추천, 자연어 처리, 대화형 AI** | ☑️ **멀티모달 기반 AI가 필요한 경우 (이미지+텍스트 분석 등)** |
| **단점** | ❌ GPT-4에 비해 성능이 낮음 | ❌ 응답 속도가 상대적으로 느림<br>❌ 비용 대비 가성비가 낮음 |

---

## 4. 결정 (Decision)

☑️ **GPT-3.5-Turbo를 선택**

- **Spring AI에서 공식 지원**하여 손쉽게 연동 가능
- **비용 대비 성능(가성비)이 뛰어남** (GPT-4는 성능이 더 뛰어나지만 비용이 훨씬 높음)
- **실시간 응답 속도가 빠르고**, 높은 요청량을 효율적으로 처리 가능
- **사용자 맞춤 추천**에 필요한 **문맥 유지 기능**이 뛰어남

---

## 5. 근거 (Justification)

- ☑️ **비용 효율성이 가장 높음** → GPT-4 대비 API 비용 절감
- ☑️ **Spring AI에서 공식적으로 지원** → 연동이 간편
- ☑️ **실시간 응답 최적화** → 사용자 맞춤 추천 빠르게 제공
- ☑️ **대량의 문맥 처리** → 이전 대화 기록을 활용해 더 정밀한 추천 가능

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **비용 절감** → GPT-4 대비 API 비용 절감
  - **빠른 응답 속도** → 사용자 경험 향상
  - **Spring AI와 원활한 연동** → 개발 편의성 증가
- **부정적 영향**
  - **최신 AI 모델(GPT-4, Gemini)** 대비 성능이 낮음
  - **멀티모달 기능 부족** → 이미지 기반 추천 필요 시 Gemini 등 고려

---

## 7. 구현 전략 (Implementation Strategy)

1. **Spring AI**로 OpenAI API 연동
   - `WebClient` 사용해 GPT-3.5-Turbo 호출
   - Spring Security와 통합하여 API 호출 보호
2. **비용 절감을 위한 캐싱/프롬프트 최적화**
   - Redis로 동일 질문 응답 캐싱
3. **실시간 추천 시스템 최적화**
   - 이전 대화 문맥 유지
   - 사용자 선호도 반영한 메뉴 추천 로직

---

## 8. 향후 고려 사항 (Future Considerations)

- **GPT-4**로 업그레이드 고려 (비용 절감 방안 확보 시)
- **Gemini**의 멀티모달 기능 검토 (이미지+텍스트 추천 필요 시)
- **AI 모델 Fine-tuning**/커스텀 모델 도입 (사용자 데이터 기반 최적화)

---

### ☑️ 결론: **GPT-3.5-Turbo 채택 (비용 대비 성능 최적화)**

**Spring AI와의 원활한 연동**, **빠른 응답 속도**, **가성비 높은 비용**을 고려해 **GPT-3.5-Turbo**를 채택.

GPT-4나 Gemini 대비 성능은 낮지만, **사용자 맞춤 추천**엔 충분하며,
**비용 절감** 효과가 커서 최적의 선택이라 판단.

</details>


<details>
<summary><h3>💡 캐싱을 해봅시다!</h3></summary>

## 1. 배경 (Background)

**AI 채팅 내역 및 오픈 채팅 내역**과 **지도 검색 데이터**의 조회 성능을 최적화하기 위해 Redis를 도입하였습니다.

MySQL만을 사용하면 **자주 조회되는 데이터의 응답 속도가 느려지고**, 데이터베이스 부하가 증가할 수 있으므로,
Redis를 활용한 캐싱 전략을 적용하여 성능을 개선하였습니다.

---

## 2. 요구사항 (Requirements)

- **AI 채팅 및 오픈 채팅 히스토리**:
  - 최근 채팅 내역을 빠르게 불러올 수 있어야 함
  - MySQL과의 **캐싱 일관성 유지**가 필요함
- **지도 검색 데이터**:
  - **자주 조회되는 장소 데이터는 빠르게 응답**해야 함
  - **DB 저장 없이 Redis에서만 관리**하여 조회 성능 최적화
  - 불필요한 DB 트래픽 감소

---

## 3. 고려한 대안 (Alternatives)

### AI 채팅 및 오픈 채팅 히스토리 캐싱 방식

| 비교 항목 | **Cache-Through 방식 (☑️ 선택)** | Write-Through 방식 | Write-Behind 방식 |
| --- | --- | --- | --- |
| **작동 방식** | Redis 조회 → 없으면 MySQL에서 조회 후 Redis에 저장 | MySQL에 저장할 때 Redis에도 동시 저장 | MySQL에 저장 후 일정 주기로 Redis 업데이트 |
| **장점** | ☑️ **조회 성능 최적화** (Redis 우선 조회)<br>☑️ MySQL 부하 감소<br>☑️ **자주 조회되는 데이터 캐싱**에 적합 | ☑️ 데이터 일관성 유지 (DB와 Redis 동기화) | ☑️ 데이터 적재 부담 감소 (배치 처리) |
| **단점** | ❌ Redis에 저장된 데이터 만료 시 MySQL 조회 발생 | ❌ MySQL과 Redis를 동기화해야 함 | ❌ 실시간성이 떨어질 수 있음 |

### 지도 검색 캐싱 방식

| 비교 항목 | **Redis 캐싱 전용 (☑️ 선택)** | MySQL + Redis 캐싱 |
| --- | --- | --- |
| **작동 방식** | Redis에만 저장, MySQL에는 저장하지 않음 | MySQL에 저장하고 Redis에 캐싱 |
| **장점** | ☑️ **빠른 조회 속도** (DB 조회 불필요)<br>☑️ **서버 부하 감소** | ☑️ Redis 캐싱 만료 시 MySQL에서 조회 가능 |
| **단점** | ❌ Redis 만료 시 데이터 손실 가능 | ❌ MySQL 부하 증가 가능 |

---

## 4. 결정 (Decision)

☑️ **AI 채팅 내역 및 오픈 채팅 내역** → **Cache-Through 방식** 적용

☑️ **지도 검색 데이터** → **Redis 캐싱 전용 (DB 저장 없음)** 적용

---

## 5. 근거 (Justification)

- ☑️ **AI 채팅 내역 조회 시 Redis 우선 조회** → 빠른 응답 속도
- ☑️ **MySQL 부하 감소** → 자주 조회되는 데이터 Redis로 이동, DB 쿼리 부담 완화
- ☑️ **지도 검색**은 실시간성 중요 → Redis 캐싱 전용으로 빠른 검색
- ☑️ **Cache-Through 방식**으로 Redis 데이터 유효성 보장

---

## 6. 영향 (Impact)

- **긍정적 영향**
  - **AI 채팅 내역 조회 속도** 향상 (Redis 우선 조회)
  - **DB 부하 감소** (읽기 요청이 Redis 처리)
  - **지도 검색**에서 **초고속 조회** (DB 조회 없이 인메모리 검색)
- **부정적 영향**
  - **Redis 캐싱** 만료 시 MySQL 조회 급증 가능성
  - **지도 검색 데이터**는 Redis 초기화 시 재적재 필요

---

## 7. 구현 전략 (Implementation Strategy)

1. **AI 채팅 & 오픈 채팅 (Cache-Through 적용)**
   - Redis에서 먼저 조회 (`GET chat_history:{user_id}`)
   - Redis에 없으면 MySQL 조회 후 Redis에 저장 (`SETEX chat_history:{user_id} 3600`)
   - 일정 시간 후 Redis 자동 삭제 (TTL)
2. **지도 검색 데이터 (Redis 캐싱 전용, DB 저장 없음)**
   - 지도 검색 요청 시 Redis에서만 데이터 조회 (`GET location:{query}`)
   - Redis에 없으면 API/외부 소스에서 가져와 Redis 저장 (`SETEX location:{query} 86400`)
   - 주기적으로 Redis 데이터 업데이트 (필요 시 갱신)

---

## 8. 향후 고려 사항 (Future Considerations)

- **Redis 데이터 만료 정책** 최적화 (채팅 내역 TTL 등)
- **Redis 클러스터** 검토 (대규모 트래픽 대비 확장성 확보)
- **데이터 손실 방지** 위한 백업 전략 (지도 검색 데이터 재적재 방안)

---

### ☑️ 결론: **Cache-Through + Redis 캐싱 전용**

- **AI 채팅 & 오픈 채팅**: **Cache-Through**로 MySQL 부하 줄이고 속도↑
- **지도 검색**: **Redis 캐싱 전용**(DB 저장 없음)으로 빠른 검색 보장
- **Redis 적극 활용**으로 시스템 성능 최적화 & DB 부하 최소화

</details>




<details>
<summary><h3>💡 EC2 배포를 할 때 서버를 분리하는 게 좋을까요?</h3></summary>

### 단일 서버 vs 서버 분리 ☑️

|                     | **단일 서버 배포**                                                                                                        | **서버 분리 배포 ☑️**                                                                                                                                                  |
|---------------------|---------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **배포 방식**       | 한 EC2 인스턴스에 앱서버, MySQL, Redis 등의 어플리케이션을 함께 배포                                                     | 어플리케이션을 각각 다른 인스턴스에 분리하여 배포                                                                                                                    |
| **특징**           | **1. 간편한 관리**<br>- 중앙 집중 관리: 관리 효율성 ⬆️<br>- 배포 과정 간소화<br><br>**2. 비용 절감**<br>- 인스턴스 비용 절약: 하나의 인스턴스만 사용하면 임대료 절약 가능<br><br>**3. 빠른 통신**<br>- 여러 애플리케이션이 동일 인스턴스 내에서 실행 → 애플리케이션 간 통신 속도 빠름<br><br>**4. 개발 및 테스트 용이**<br>- 통합 환경: 단일 인스턴스에서 개발 및 테스트 환경을 구축하여 개발 및 테스트 과정이 용이 | **1. 성능 향상**<br>- **리소스 분리**: CPU, 메모리, 네트워크를 분리해 과부하를 낮추고 성능을 높임<br><br>**2. 확장성**<br>- **독립 확장**: 메인 서버, Redis, MySQL 각각 스케일 업/스케일 아웃 가능<br><br>**3. 고가용성 및 안정성**<br>- **장애 격리**: 각 서비스가 독립된 인스턴스에 배포 → 장애 발생 시 다른 서비스에 미치는 영향 최소화<br>- **독립적인 업데이트 및 유지보수**: 특정 컴포넌트를 업데이트·점검해도 다른 컴포넌트에 영향이 적음<br><br>**4. 보안 강화**<br>- **네트워크 보안**: 각 EC2 인스턴스마다 다른 보안 그룹을 적용<br>- **접근 제어**: 서버 역할과 데이터를 분리하여 더 세부적인 보안 설정 가능<br><br>**5. 비용 최적화**<br>- 필요한 리소스에 따라 EC2 인스턴스 유형을 다르게 설정 가능 |

</details>





<details>
<summary><h3>💡 로드 밸런서 사용의 장점은 무엇일까요?</h3></summary>

### 📌 로드 밸런서 (Load Balancer)란?

로드 밸런서는 여러 서버에 트래픽을 균등하게 분산하여 애플리케이션의 가용성과 성능을 최적화하는 기술입니다.
사용자의 요청을 가장 적절한 서버로 자동 배분하여 트래픽 병목을 방지하고,
시스템 안정성을 높이는 역할을 합니다.

---

## 로드 밸런서의 장점

### 🔹 트래픽 제어

- ☑️ 한 서버에서 트래픽 병목 현상 방지
- ☑️ 다수의 서버로 요청을 분산하여 부하 최소화

### 🔹 서버 안정성

- ☑️ 특정 서버가 다운되더라도 다른 서버로 자동 전환 (Failover)
- ☑️ 애플리케이션 운영 중에도 유지보수 & 업그레이드 가능

### 🔹 성능 향상

- ☑️ 네트워크 지연 시간 줄여 응답 속도 개선
- ☑️ 지리적으로 가까운 서버로 리디렉션하여 빠른 서비스
- ☑️ 서버 간 로드를 균등 분산으로 성능 최적화

### 🔹 보안 강화

- ☑️ 방화벽 그룹과 연계한 보안 계층 추가
- ☑️ DDoS 공격 분산 처리로 서비스 중단 방지

---

## 🛠 주요 적용 기술

- ☑️ **L4 로드 밸런싱** : TCP/UDP 계층에서 트래픽 분산
- ☑️ **L7 로드 밸런싱** : HTTP/HTTPS 계층에서 URL, 쿠키, 헤더 기반 라우팅
- ☑️ **클라우드 로드 밸런서** : AWS ELB, GCP Load Balancing, Nginx, HAProxy 등

로드 밸런서를 활용하면 **안정적인 서비스 운영**과 **성능 최적화**를 동시에 달성할 수 있습니다!

</details>



<details>
<summary><h3>💡 CI/CD 툴은 무엇을 사용해야할까요?</h3></summary>

### Jenkins vs Github Actions ☑️

|                   | **Jenkins**                                                                                     | **GitHub Actions ☑️**                                                                                                                    |
|-------------------|--------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| **서버**          | 별도의 서버 설치 필요                                                                           | 클라우드로 작동 (별도 설치 X)                                                                                                            |
| **비용**          | 툴은 무료지만 서버 유지 비용 O                                                                   | - public Repository에서 무료<br>- private Repository는 유료지만 무료 사용분 O                                                                 |
| **플러그인**      | 1900개 이상의 플러그인 존재                                                                      | Jenkins에 비해 적음.<br>스크립트로 플러그인 추가 가능.                                                                                    |
| **사용성**        | - GUI라 친근<br>- 초기 설정이 까다로움<br>- 호스팅을 직접해야 함 → 서버 운영 및 관리 비용 발생 | - GitHub 사용 개발자에게 친숙<br>- 초기 설정이 쉬움                                                                                       |
| **자료**          | 전 세계 많은 사람들이 이용<br>→ 문서가 다양                                                     | Jenkins에 비해 문서가 적음                                                                                                               |
| **총평**          | - 많은 플러그인과 자료가 존재하지만 서버 설치가 필요<br>- 소규모 프로젝트에서는 초기 세팅에 리소스가 불필요하게 투입될 수 있음 | - GitHub에서 사용해 친숙<br>- 별도의 설치 없이 클라우드에서 관리 가능<br>- deploy.yaml 파일만 작성해도 쉬운 파이프라인 구성<br>- CI/CD 과정을 GitHub에서 볼 수 있어 실행·디버깅 용이 |

</details>


<details>
<summary><h3>💡 프론트엔드 배포툴은 무엇을 사용해야 할까요?</h3></summary>

### Vercel vs EC2+NGINX vs CloudFront+S3 ☑️

|                   | **Vercel**                                                                                                  | **EC2 + NGINX**                                                                                                                 | **CloudFront + S3 ☑️**                                                                                                                                                                 |
|-------------------|--------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **주요 특징**     | - 간단하고 빠른 배포<br>- 자동화된 CI/CD<br>- Next.js, React 등 프레임워크 지원                           | - 높은 자유도와 설정 가능성<br>- Nginx 웹 서버를 활용한 성능 최적화<br>- EC2 인스턴스 관리 필요<br>- Docker로 배포환경 구축 용이 | - CDN 서비스<br>- 정적 자산 전송에 특화<br>- 글로벌 배포 및 캐싱<br>- S3와 함께 사용 가능 (정적 웹사이트 배포에 특화, React 내부 라우팅 기술 O)                                                                             |
| **장점**          | - **사용 편의성**: 인프라 관리 부담 없음<br>- **빠른 배포 속도**: 빌드 & 배포 자동화<br>- **다양한 기능**: 미리보기 배포, A/B 테스팅 등 | - **유연성**: 서버 환경 자유롭게 구성 가능<br>- **성능**: Nginx 활용한 웹 서버 최적화<br>- **확장성**: EC2 인스턴스 확장으로 트래픽 증가 대응<br>- **비용**: EC2 프리티어 사용 시 비용 절감 | - **빠른 전송 속도**: CDN으로 전 세계 사용자에게 빠른 콘텐츠 제공<br>- **안정성**: 분산된 서버로 안정적 서비스<br>- **비용 효율성**: 트래픽에 따라 지불<br>- 백엔드 EC2 배포 시 AWS Cloud 내 모든 배포 가능                                                        |
| **단점**          | - Vercel 플랫폼 종속<br>- 커스터마이징 제한<br>- WebSocket 미지원<br>- 사용량 증가 시 비용 발생            | - 서버 구축, 설정, 관리 등 개발자 부담<br>- 초기 설정 및 최적화에 시간·노력 필요<br>- 서버 보안 책임(개발자)                                                     | - CloudFront 설정 & S3 연동 과정 복잡<br>- 트래픽·요청 증가 시 비용 발생                                                                                                                                           |

</details>



---


## 🍙 트러블슈팅

---


Tasteful-AI 트러블 슈팅 (1)

# WebSocket 연결 후 사용자 인증 시 JWT 인증이 되지 않는 문제 발생 및 해결 방법

[WebSocket 인증 및 Spring Security와 충돌 문제](https://www.notion.so/WebSocket-Spring-Security-192c6e685f1081f0975acb55f53cc8fa?pvs=21)

[JPA에서  Member ID 조회로 인한 `UnsatisfiedDependencyException` 발생](https://www.notion.so/JPA-Member-ID-UnsatisfiedDependencyException-192c6e685f10819da90efc2ecbaf2449?pvs=21)

[N+1 문제 해결 - findMemberWithTasteById()](https://www.notion.so/N-1-findMemberWithTasteById-192c6e685f1081268b53dfd01021a1c1?pvs=21)

[Redis에서 관리하는 AI 채팅 세션과 추천 내역 Repository의 복잡도 증가](https://www.notion.so/Redis-AI-Repository-192c6e685f1081f99023c2ef22f8bbec?pvs=21)

[AI 채팅 히스토리 삭제 시 MySQL과 Redis의 데이터 동기화 문제 발생](https://www.notion.so/AI-MySQL-Redis-192c6e685f1081439c3defec316c8e5a?pvs=21)

[단위 테스트 진행 시 **`NullPointException`** 발생 원인 및 해결 방법](https://www.notion.so/NullPointException-192c6e685f108105b76bf373bc7e915d?pvs=21)

[**JPA 영속성 컨텍스트로 인한 이미지 삭제  오류 해결**](https://www.notion.so/JPA-192c6e685f108185a16dc7d5f59b7ee8?pvs=21)

[**S3 정적 호스팅 페이지 새로고침 시 페이지 다이렉트 실패 문제 해결**](https://www.notion.so/S3-192c6e685f108129bf11de66d28cfe2a?pvs=21)

[docker 연결 중 레디스 연결이 안 되는 문제 해결 ](https://www.notion.so/docker-192c6e685f1081718135da48ff056789?pvs=21)

[Mac으로 Docker 배포 시 생기는 **CPU 아키텍쳐 호환문제 해결**](https://www.notion.so/Mac-Docker-CPU-192c6e685f108185b5a1d0f05055da5c?pvs=21)

[**Jackson 역직렬화 오류 해결 방법**](https://www.notion.so/Jackson-192c6e685f1081318485ff1920ac4223?pvs=21)

[**403 FORBIDDEN 에러 발생 원인 및 해결 방법**](https://www.notion.so/403-FORBIDDEN-192c6e685f10812c8643e7952c19442b?pvs=21)
---

## 🍙 CONTRIBUTORS

---

| 팀원명 | 포지션 | 담당(개인별 기여점) | 깃허브 링크 |
| --- | --- | --- | --- |
| 허수연 | 리더 | ▶ AI 채팅
- Spring AI를 활용하여 OpenAI 연결 및 프롬프트 최적화
- 취향 카테고리를 사용한 사용자 맞춤 메뉴 추천 기능 구현
- Redis로 일일 채팅 횟수 관리, `@Scheduled`를 사용하여 매일 자정마다 횟수 초기화 
- Redis로 AI 채팅 세션 관리, 세션 종료 시 히스토리 데이터 삭제로 불필요한 데이터 누적 방지
- AI 채팅 히스토리 내역을 Redis 일정 시간 동안 저장, 필요시 데이터 조회하도록 구현
- Redis 키 관리 최적화 `TTL` 적용하여 만료된 데이터가 자동으로 삭제되도록 관리

▶ 취향 카테고리 Taste
- 취향 카테고리 CRUD (수정 및 조회)
- Taste 설계 변경 및 엔티티 확장 리팩토링
- `@EntityGraph` `LEFT JOIN FETCH` 쿼리 최적화

▶ 프론트엔드
- React 초기 세팅과 경로 설정 및 AI 채팅 화면 구현

▶ 테스트 
- `Junit5` + `Mockito` 기반 단위 테스트 작성

▶ 프로젝트 일정 관리
- 정규 회의 진행 및 데일리 스크럼 작성
- 프로젝트 전체 일정 관리
- 팀원의 개인 업무 일정 관리
- 개발 프로세스 가이드 작성 및 팀 노션 관리 | https://github.com/sooyeoneo |
| 정가현 | 부리더 | ▶ 사용자 프로필
- 닉네임 수정
- 프로필 조회

▶ 프로필 이미지 업로드
- AWS S3 활용한 이미지 업로드(수정) 및 삭제 

▶ 백엔드 배포
- `CI/CD`를 활용한 배포 자동화
- `ALB` 로드밸런싱 적용 (앱서버 이중화)
- `Docker`를 사용한 서버 분리배포

▶ 프론트엔드 배포
- S3 + CloudFront 활용 배포
- ALB 로드밸런싱 적용
- `Route S5` 도메인 적용
- SSL 인증서 발급

▶ 프론트엔드
- 마이페이지 화면

▶ 테스트 
- 사용자 프로필, 이미지 업로드 테스트코드 작성 | https://github.com/kahyun0608 |
| 김지윤 | 팀원 | ▶ 오픈 채팅
- WebSocket + STOMP + SockJS를 이용한 메시지 송수신 기능 구현
- Redis `Pub/Sub`을 활용한 다중 서버 환경에서의 확장성 보장
- `StompHandler`를 이용한 WebSocket 인증 및 권한 관리 적용
- MySQL을 이용한 영구적 메시지 저장 
- Redis를 활용한 빠른 메시지 조회 최적화 및 캐싱

▶ 테스트 
- `Junit5` + `Mockito` 기반 채팅 기능에 대한 단위 테스트

▶ 프론트엔드
- React 기반 UX/UI 설계 및 인터페이스 구현
- `Axios`를 이용한 백엔드 API 연동 및 데이터 처리
- `Redux`를 활용한 상태 관리 | https://github.com/jiyoon0000 |
| 백은영 | 팀원 | ▶ 회원 & 인증.인가 
1) Spring Securiry 기반 인증 및 권한 관리
- 로그인 및 회원가입 시 `JWT Access Token` & `Refresh Token` 발급
2) 회원 관리 기능(USER)
- 회원가입, 로그인, 로그아웃
- 비밀번호 변경/검증, 회원 탈퇴
3) 관리자 기능(ADMIN)
- 회원 전체 내역 조회
- 회원 강제 추방
4) Redis를 활용한 토큰 관리
- `Refresh Token`을 Redis에 저장하여 빠른 인증 처리
- 로그아웃 시 토큰 블랙리스트 등록

▶ 카카오 지도 API 키워드 검색
- 사용자가 특정 음식을 입력하면 맛집 리스트 조회
- 검색된 결과를 지도 위에 마커로 표시

▶ 테스트 
- `Junit5` + `Mockito` 기반 단위 테스트 작성

▶ 프론트엔드
- 회원 가입, 로그인, 로그아웃, 회원 관리 관련 화면 구현
- 지도 검색 화면 구현(카카오 지도 API 연동) | https://github.com/beunyeong |


그대로 복붙하니까 토글이 누락되서 추가해서 README.md 에 넣을 마크다운 만들어줘
